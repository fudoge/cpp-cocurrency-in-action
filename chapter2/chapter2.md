# 2장. Managing Threads

어떻게 스레드를 실행하고, 어떻게 이들이 끝났는지 확인할 수 있을까?
C++ STL은 대부분의 스레드 관리를 비교적 쉽게 해준다.
모든 것이 `std::thread` 객체에 연관되어있다.
이러한 작업들이 똑바르진 않지만, 라이브러리는 기본적인 빌드에 필요한 유연함들을 제공한다.

이 챕터에서는, 기본부터 시작한다.
스레드를 시작시키고, 끝나는 것을 기다리거나 백그라운드에서 동작되도록 할 것이다.
그리고, 하나의 `std::thread` 객체에서 다른 하나로 소유권을 넘기는 것에 대한 함수에 대한 추가적인 파라미터를 봐볼 것이다.

## 2.1: 기본적인 스레드 관리

모든 C++ 프로그램은 C++런타임에 쓰이는 적어도 하나의 스레드를 실행한다..
그 스레드는 `main()`을 실행하는 스레드이다.
당신의 프로그램은 다른 함수를 시작점으로 가지는 추가적인 스레드를 실행시킬 수 있다.

이러한 스레드들은 처음 스레드를 포함해서 다른 스레드들과 동시에 실행된다.
프로그램이 `main()`함수에서 반환될 때 프로그램이 종료되는 것처럼, 지정된 진입점 함수가 반환되면 스레드가 종료된다.
`std::thread` 객체가 스레드에 대해 있을 경우, 스레드가 끝날 때까지 기다릴 수 있다.

그러나, 스레드를 먼저 시작해야 하므로, 스레드를 실행하는 법을 찾아보자.

### 2.1.1: 스레드 실행하기

챕터 1에서 보았듯이, 스레드는 스레드가 실행해주길 바라는 `task`를 명시하면서 `std::thread` 객체를 생성함으로써 시작된다.
가장 단순한 경우, `task`는 아무 파라미터와 반환값이 없는 플레인한 함수이다.
이 함수는 그만의 스레드에서 리턴할때까지 실행되고, 그 뒤 스레드는 멈춘다.

반대로, task는 추가 매개변수를 받는 함수 객체일 수 있으며, 실행 중에 어떤 종류의 메시징 시스템을 통해 지정된 일련의 독립적인 작업을 수행할 수 있다.
이 경우, 스레드는 역시 어떤 종류의 메시징 시스템을 통해 종료 신호를 받을 때만 멈추게 된다.
스레드가 무엇을 할 것이고, 어디서 시작되는지는 상관없다.
C++ STL에서의 스레드 사용은, `std::thread` 객체를 생성하는 것으로 범위가 좁혀진다.

```cpp
void do_some_work();
std::thread my_thead(do_some_work);
```

간단히 하자면 위와 같다.
물론 컴파일러가 `std::thread`를 사용할 수 있도록 `<thread>`헤더를 포함해놔야 한다.
다른 많은 C++STL과 마찬가지로,  `std::thread`는 아무 호출 가능한 타입과 동작한다.
`std::thread` 생성자에 함수 호출 연산자를 가진 클래스의 인스턴스를 대신 전달할 수 있다.
```cpp
class background_task {
public:
    void operator()() const {
    do_something();
    do_something_else();
    }
};

background_task f;
std::thread my_thread(f);
```

이 경우에서, 제공된 함수 객체는 다음에 속하는 저장소(실행 스레드를 새로 만들어 그곳에서 실행됨) 으로 복사된다.
복사본은 원본과 동등하게 동작하거나, 결과가 예상치 못하게 흘러갈 수 있다.
함수 객체를 스레드 생성자에 전달할 때 고려해야 할 사항은 “C++의 가장 골치 아픈 해석”을 피하는 것이다.

만약 당신이 이름이 있는 변수가 아닌 임시 값을 넘기면, 문법은 함수 선언의 문법과 동일할 수 있으며, 이 경우 컴파일러는 개체 정의가 아닌 함수 선언으로 해석한다.

예를 들어,

```cpp
std::thread my_thread(backtround_task());
```
는 하나의 파라미터(`background_task` 객체를 반환하는 파라미터가 없는 함수 포인터)를 가진, 그리고 새로운 스레드를 시작하는 것이 아닌, 스레드 객체를 반환하는 `my_thread` 함수를 선언한다.

당신은 이전에 보인 것처럼 괄호쌍을 쓰거나 새로운 초기화 문법을 사용함으로 함수 객체에 이름을 정의하면서 해결할 수 있다.
예를 들어,

```cpp
std::thread my_thread((background_task())); // 1
std::thread my_thread{background_task()}; // 2
```

처럼 말이다.

1에서는 추가된 괄호쌍이 함수 선언의 내용을 바꾼다.
`my_thread`를 `std::thread`형의 변수의 선언으로 허용하는 것이다.
2번은, 새로운 표준 초기화 문법을 쓰는 것이다. 이도 변수의 선언으로 허용한다.

이러한 문제를 피하는 호출가능한 객체의 한 종류는 람다식이다.
C++11에 추가된 기능인데, 지역변수를 쓰고 추가적인 매개변수의 필요를 피하는 지역함수를 쓸 수 있게 해준다.
이전의 예시는 아래의 람다식으로 대체될 수 있다:

```cpp
std::thread my_thread([] {
	do_something();
	do_something_else();
});
```

당신이 스레드를 한 번 실행하면, 당신은 스레드가 완료될때까지 기다릴지(`join`), 아니면 독립적으로 실행할지(`detach`)를 명시적으로 결정해야 한다.
`std::thread`객체가 소멸되기 전에 이러한 결정을 내리지 않으면 프로그램이 종료된다.
(`std::thread` 소멸자는 `std::terminate()`를 호출한다.)
따라서, 예외 상황에서도 스레드가 올바르게 `join` 또는 `detach`되도록 보장하는 것은 필수적이다.

이 시나리오의 처리는 2.1.3에 있다.
`std::thread` 객체가 소멸되기 전에 이 결정을 내려야 한다 - 스레드 자체는 `join`하거나 `detach`하기 훤씬 전에 완료될 수 있고, 만일 당신이 `detach`한 경우, `std::thread` 객체가 소멸되고도 계속 실행될 수도 있다.

만약 당신이 스레드를 종료하는 것을 기다리지 않는다면, 당신은 스레드에 의해 접근되는 데이터가 스레드가 종료될 때까지 유효함을 보장해야 한다.

이것은 새로운 문제가 아니다.
싱글스레드의 코드에서도 객체가 없어진 후 접근하는 것은 정의되지 않은 동작이지만, 스레드를 사용할 때는 이러한 수명 문제를 겪을 더 많은 기회를 접하게 된다.
그러한 문제에 직면하는 상황들 중 하나는 스레드 함수가 로컬변수에 대한 포인터나 참조를 가지고 함수가 종료될 때에도 스레드가 종료되지 않을 때이다.

아래의 예시는 그러한 시나리오이다.

```cpp
// Listening 2.1: 
// A function that returns while a thread still has access to local variables

#include <thread>

struct func {
    int &i;
    func(int &i_) : i(i_){}

    void operator()() {
        for (unsigned j = 0; j < 1000000; ++j) {
            do_something(i);
        }
    }
};

void oops() {
    int some_local_state = 0;
    func my_func(some_local_state);
    std::thread my_thread(my_func);
    my_thread.detach();
}
```

여기서, 새로운 스레드는 `my_thread`객체와 관계가 맺어지고, `oops()`가 끝날 때에도 실행이 될 것이다.
당신은 `detach()`로 스레드를 기다리지 않기로 했기 때문이다.
스레드가 여전히 실행 중이라면, 다음 호출에서의 `do_something(i)`은 사라진 변수에 접근할 것이다.

이는 일반적인 싱글스레드 코드와 같다. 지역 변수에 대한 포인터 또는 참조 외부 함수로 넘기는 것을 허용하는 것은 좋은 아이디어가 아니다. 
멀티스레드 환경에서는 더 실수가 나기 좋다.
당장은 문제가 보이지 않기 때문이다.

이러한 시나리오를 다루는 한 일반적인 방법은 스레드 함수에서 데이터를 참조하는 것이 아닌, 데이터의 복사본을 가지고 있는 것이 좋다.
스레드 함수에 호출 가능한 객체를 사용한다면, 그 객체는 스레드에 복사된다. 기존 객체는 즉시 없어질 수 있다.
그러나 당신은 여전히 객체가 포인터 또는 참조를 가지는 것에 대해 주의하여야 한다.
[Listening 2.1]이 그런 경우이다.

특히, 함수에서 어떠한 로컬변수에 참조하는 것은 좋지 않다. 스레드가 그 스레드를 호출시킨 함수가 끝나기 전에  종료되는것이 보장되어도 말이다.
대안으로, 당신은 `join`을 통해 기존 함수가 스레드의 호출을 기다려주도록 할 수 있다.

### 2.1.2: 스레드가 완료되기까지 기다리기

만약 당신이 스레드를 기다리고 싶다면, `std::thread` 인스턴스에 연관된 `join()`을 통해서 가능하다.
[Listening 2.1]에서 `my_theread.detach()`를 `my_thread.join()`으로 대체하면, 함수가 끝나기 전에 생성된 스레드를 기다렸다가 끝낸다.
이 경우, 스레드를 분리하여 함수를 실행하는 것에는 거의 의미가 없다.
최초의 스레드는 하는 일이 없기 때문이다.

그러나 실제 코드에서는 원래의 스레드가 자체적으로 작업을 수행하거나 여러 스레드를 실행하여 모두 완료할 때까지 유용한 작업을 할 수 있다.
당신이 스레드가 끝나길 기다리던 말던, `join()`은 간단하고 무식하다(brute force).
스레드가 종료되었는지 확인하거나 일정 시간 동안만 기다리는 등 더 세밀하게 스레드 대기를 제어하려면, `조건 변수`나 `future`와 같은 대안 매커니즘을 사용해야 한다.
이는 챕터 4에서 확인할 것이다.

`join()`을 호출하는 것은 스레드와 관련된 스토리지를 정리함을 의미한다.
즉, `std::thread` 객체가 더 이상 막 끝난 스레드와 연관되지 않는다.
아무런 스레드와도 관계를 맺은 상태가 아니게 된다.
이는 주어진 스레드에 `join()`호출을 한 번만 할 수 있음을 의미한다.
만약 한번 `join()`을 호출하면, 그 스레드는 더 이상 `joinable`하지 않고, `joinable()`도 `false`를 반환할 것이다.

### 2.1.3: 예외적 상황을 기다리기

이전에 언급했는데, `std::thread`객체가 사라지기 전까지 당신은 join()또는 detach()를 호출해야 한다.
만약 `detach`하기로 했다면, `detach()`를 스레드가 시작되고나서 호출하면 된다.
이건 문제가 없다.

그러나 스레드를 기다리기로 했다면, 당신은 `join()`을 어디에서 호출해야 할지 생각해봐야 한다.
이는 스레드가 시작되고 `join()` 호출전에 예외가 발생하면 호출이 건너뛰어질 수 있다는 말이다.
당신의 애플리케이션이 예외가 발생하였을 때 종료되는 것을 방지하려면, 그러한 케이스에서 어떻게 하여야 할지 결정해야 한다.
일반적으로, 예외가 없을 때 당신이 `join()`을 호출하여 한다면, 예외 발생 시에도 `join()`을 호출하여 우발적인 수명문제를 해결해야 한다.

아래 코드는 간단한 예제이다.

```cpp
// Listening 2.2
// Waiting for a thread to finish

struct func; // Listening 2.1을 참고하세요.

void f() {
    int some_local_state = 0;
    func my_func(some_local_state);
    std::thread t(my_func);
    try {
        do_something_in_currnet_thread();
    } catch (...) {
        t.join();
        throw;
    }
    t.join();
}
```

[2.2]에서의 코드는 함수가 일반적으로 끝날 경우이던, 예외가 발생하던, `try/catch` 블록으로 로컬 상태에 기존 함수가 끝나기 전에 접근할 수 있도록 보장해준다.
`try/catch`블록의 사용은 방대하고, 범위를 잘못 알기 쉽다. 이는 이상적인 시나리오가 아니다.

만약 로컬변수에 대한 참조가 있는 등, 스레드가 함수 종료 전에 끝나는 것을 보장하는 것이 중요하다면, 일반적인 상황이던, 예외적인 상황이던 모두 가능한 종료 경로에 대해 스레드가 해당하는지 확인하는 것이 중요하고, 이를 위해 간결한 매커니즘을 제공하는 것이 좋다.

하나의 방법은 표준 `RAII(Resource Acquistion Is Initialization)` 원칙을 사용하고 클래스에게 제거될 시 join()을 하도록 하는 것이다.

아래 예처럼 말이다.
함수 `f()`가 어떻게 간소화되었는지 보자.

```cpp
// Listening 2.3: 
// Using RAII to wait for a thread to complete

class thread_guard {
    std::thread& t;
public: 
explicit thread_guard(std::thread& t_): // 생성자 선언
    t(t_)
    {}
    ~thread_guard() // 소멸자 선언
    {
        if(t.joinable()) {
            t.join();
        }
    }
    thread_guard(thread_guard const&) = delete;
    thread_guard& operator = (thread_guard const&) = delete;
};

struct func; // Listening 2.1 참고

void f() {
    int some_local_state = 0;
    func my_func(some_local_state);
    std::thread t(my_func);
    thread_guard g(t);

    do_something_in_current_thread();
}
```

실행 중에서 현재 스레드의 실행이 f의 끝에 도달했을 때, 로컬 객체들은 생성의 반대 순서로 제거된다.
`thread_guard` 객체가 먼저 제거되고, 소멸자가 실행되면서 `thread`가 `join`되기까지 기다린다.

이는 함수 도중에도 일어날 수 있다. `do_something_int_current_thread`가 예외를 발생시킬 수 있기 때문이다.
[2.3]의 `thread_guard`의 소멸자는 처음에 `join()`을 호출하기 전에 `std::thread`객체가 `joinable()`한지 확인한다.
이는 중요하다. `join()`은 한 번만 실행 가능하기 때문이다. 그래서 이미 `join()`되었을 경우, 오류가 날 수도 있다.

복사 연산자와 대입 연산자는 컴파일러에 의해 자동적으로 제공되는 것을 방지하기 위해서 `=delete`로 되어 있다.
객체에 복사 또는 대입은 위험할 수 있다. 예상치 못한 변경이 생길 수도 있기 때문이다.

`deleted`로 선언하면서, `thread_guard()` 객체에 대한 복사 시도는 컴파일 에러를 불러일으킨다.
만약 `thread`가 끝나는 것을 기다릴 필요가 없다면, 당신은 예외로부터 안전한 이슈를 피하기 위해 `detach`할 수 있다.
이는 스레드와 `std::thread`의 관계를 없애고, `std::thread` 객체가 없어질 때 `std::terminate()`가 호출되지 않게 한다. 스레드가 백그라운드에서 여전히 실행 중일떄도 말이다.

### 2.1.4: 백그라운드에서 스레드 실행시키기

`detach`를 `std::thread`객체로 실행하는 것은  아무것도 그와 통신할 수 없이 스레드를 백그라운드에 실행되도록 둔다는 뜻이다.
이제 그 스레드가 끝날 때까지 기다리는 것은 불가능하다.
만약에 스레드가 `detach`되면, `std::thread`객체가 참조할 수 없어진다. 더이상 `join()`할 수도 없다.

`Detach`된 스레드들은 백그라운드에서 실행되고, 소유권과 제어권은 스레드와 관련된 자원들이 스레드가 종료될 때 확실히 정리될 수 있도록 C++ 런타임 라이브러리로 넘어간다.
Datach된 스레드는 UNIX에서 명백히 유저 인터페이스 없이 백그라운드에서 실행되는 `daemon process`라는 개념 이후에,  `daemon threads`라고도 불린다.

그러한 스레드들은 보통 오래 지속된다.그들은 애플리케이션의 생명주기 동안 전체적으로 켜져 있다.
파일시스템 모니터링, 객체 캐시에서 안쓰이는 엔트리 정리, 또는 자료구조 정리 등의 백그라운드 작업 등을 실행하면서 말이다.

반대로, 스레드가 완료된 시점이나 스레드가 “실행 후 무시(fire and forget)” 작업에 사용되는 위치를 식별하는 다른 매커니즘이 있는 분리된 스레드를 사용하는 것이 합리적일 수 있다.

섹션 2.1.2에서 보았듯이, 당신은 스레드를 멤머 함수 `detach()`를 통해서 `std::thread` 객체와 detach시켰다.
그 call이 실행되고는, 더 이상 `std::thread` 객체는 그 실제 실행중인 스레드와 관련이 없고, 그러므로 `joinable()`하지 않다.

```cpp
std::thread t(do_background_work);
t.detach();
assert(!t.joinable());
```

`std::thread`객체로부터 스레드를 `detach`하기 위해서는, `detach`할 스레드가 있어야 한다. 연관이 없는 `std::thread` 객체에는 `detach()`함수를 쓸 수 없다.

join()에서의 요구사항과 같다. 그리고 당신은 `t.detach()`를 `t.joinable()`이 `true`일 때만 사용가능하다.

워드프로세서 애플리케이션이 있고 많은 문서들을 한번에 편집한다고 해보자.
UI계층과 내부 양 측에서, 다루는 방법은 다양한다.
보편적인 한 방법은 편집되는 각 문서에 대해 하나의 여러 개의 독립적인 최상위 창을 가지는 것이다.
비록 이 창들이 각각의 고유한 메뉴가 존재하는 등 완전히 독립적으로 보여도, 동일한 애플리케이션 인스턴스 내에서 실행되고 있다.

내부적으로 이를 다루는 한 방법은 각 문서 편집 창에 하나의 스레드를 가지는 것이다. 각 스레드는 같은 코드를 가지지만, 창의 특성에 따라서 편집되는 각자 다른 데이터를 가진다.
새로운 문서를 여는 것은 새로운 스레드를 켜는 것을 말한다. 요청을 처리하는 스레드는 다른 스레드가 끝나는 것을 기다릴 필요가 없다. 관련이 없는 문서이기 때문이다. 그러므로, 분리된 스레드를 실행하는 새로운 후보를 만들어준다.

아래의 Listening은 예제를 보여준다.

```cpp
// Listening 2.4: 
// Detaching a thread to handle other documents

void edit_document(std::string const& filename) {
    open_document_and_display_gui(filename);
    while(!done_editing()) {
        user_command cmd = get_user_input();
        if(cmd.type == open_new_document()) {
            std::string const new_name = get_filename_from_user();
            std::thread t(edit_document, new_name);
            t.detach();
        } else {
            process_user_input(cmd);
        }
    }
}
```

만약에 사용자가 새 문서를 열면, 당신은 문서를 열라고 명령을 내린다. 새로운 스레드에게 그 문서를 열라고 하는 것이다. 그리고 `detach`시킨다.
새 스레드는 다른 파일에서 현재 스레드와 같은 혁할을 하기 때문에, 당신은 새롭게 지정된 파일 이름을 인자로 받아서 똑같은 함수를 재사용 가능하다. (`edit_document` 같은)
이러한 예시는 스레드를 시작할 때 함수에 인자를 전달할 때 유용하다.
생성자에서 함수를 줄 뿐만 아니라, 이름까지 주었다.

매개변수가 있는 일반함수 대신 멤버 데이터가 있는 함수 개체를 사용하는 등 다른 매커니즘을 사용할 수 있지만, 스레드 라이브러리를 사용하면 쉽게 작업할 수 있다.

## 2.2: 스레드 함수에 인자 전달하기